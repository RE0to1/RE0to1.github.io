[{"id":"d64659329def39dfcfebee29f3057513","title":"这是测试代码","content":"","slug":"这是测试代码-1","date":"2022-10-11T01:56:08.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"d64659329def39dfcfebee29f3057513","title":"这是测试代码","content":"","slug":"这是测试代码","date":"2022-10-11T01:55:44.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"1c7f546419faba8ea2a992fedd8a6f51","title":"article title","content":"","slug":"article-title","date":"2022-10-10T08:44:13.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-10T08:29:03.534Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"构造方法私有，外界就不能再创建对象了\n如何使用帮助文档1：打开帮助文档\n2：点击显示，找到索引，看到输入框\n3：知道你要找谁？以Scanner举例\n4：再输入框里面输入Scanner，然后回车\n5：看包 java.lang包下的类不需要导入，其他的全部需要导入\n6：再简单的看看类的解释和说明，别忘了看该类的版本\n7：看类的结构\n成员变量  字段摘要\n构造方法 构造方法摘要\n成员方法  方法摘要\n8：学习构造方法\nA:有构造方法 就创造对象\nB:没有构造方法   成员可能都是静态的\n9：节哀吧成员方法\nA:左边\n是否静态：如果静态，可以通过类名调用\n返回值类型：人家返回什么，你就用什么接收\nB:\n看方法名：方法名称不要写错\n参数列表：有几个写几个\n代码块：再java中，使用{}括起来的代码被称为代码块局部代码块：局部位置，再方法中出现；限定变量生命周期，及早释放提高内存利用率\n构造代码块：在类中的成员位置用{}括起来的代码。每次调用构造方法执行前，都会线执行构造代码块\n作用：可以把多个构造方法中的共同代码放在一起\n静态代码块：在类中的成员位置用{}括起来的代码。只不过它用static修饰\n作用：一般事对类进行初始化\n静态代码块，构造代码块，构造方法的执行顺序？静态代码块–构造代码块—构造方法\n静态代码块：只执行一次\n构造代码块：每次调用构造方法都执行\n继承概述：把多个类中相同的内容给提取出来定义道一个类中。class 子类名 extends 父类名{ }\n好处：a提高代码复用性b提高代码的维护性c让类与类产生关系，是多态的前提\n类与类产生了关系，其实也是继承的一个弊端？\n类的耦合性增强了\n开发原创：低耦合，高内聚。\n耦合：类与类的关系\n内聚：就是自己完成某件事情的能力\nJava中继承的特点：\nA：Java只支持单继承，不支持多继承、有些语言是支持多继承的\nB：java支持多层继承（继承体系）\n继承的注意事项：\nA：子类只能继承父类所有非私有的成员（成员方法和成员变量）\nB：子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法\nC：不要为了部分功能而去继承\n那么我们什么时候考虑使用继承呢？\n继承其实体现的是一种”is a“。\n采用假设法：\n如果有两个类A,B只有他们符号A是B的一种，或者B是A的一种，就可以考虑使用继承\n继承中成员变量的关系：\nA:子类中的成员变量和父类的成员变量名称不一样\nB:子类中的成员变量和父类的成员变量名称一样(就近原则)\n在子类方法中访问一个变量的查找顺序：\na：在子类方法中的局部范围找，有就用\nb：在子类的成员范围找，有就用\nc:在父类的成员范围找，有就用\n成员范围看不见成员方法的内部变量\n问题：我不仅仅要输出局部范围的num，还要输出本类成员范围的num怎么办？父类成员范围？用this.变量名 。super.变量名\nthis和super的区别？分别是什么？\nthis代表本类对应的引用\nsuper代表父类存储空间的标识（可以理解为父类引用，可以操作父类的成员）\n怎么用呢？\nA：调用成员变量\nthis.成员变量 调用本类的成员变量\nsuper.成员变量调用父类的成员变量\nB:调用构造方法\nthis（…）调用本类的构造方法\nsuper（…）调用父类的构造方法\nC:调用成员方法\nthis.成员方法    调用本类的成员方法\nsuper.成员方法  调用父类的成员方法\n继承中构造方法的关系\nA：子类中所有构造方法默认都会访问父类中空参数的构造方法\nB:为什么？因为子类会继承父类中的数据，还可能使用父类的数据，所有子类初始化之前，一定要先完成父类数据的初始化。\n注意：子类每一个构造方法的第一条语句默认都是：super（）；\n\n如果父类没有无参构造方法，那么子类中的构造方法会出现什么现象如何解决？\n报错\n如何解决？\nA:在父类中加一个无参构造方法\nB:通过super关键字去显示的调用父类的带参构构造方法\nC：子类通过this去调用本类的其他构造方法\n子类中一定要有一个去访问父类的构造方法，否则父类数据就没有初始化\n注意事项：\nthis（…）或者super（…）必须出现在第一条语句上。\n如果不是放在第一条语句上，就可能对父类的数据进行多次初始化\n一个类的初始化过程成员变量初始化–默认初始化–显示初始化–构造方法初始化\n继承中·成员方法的关系\n如果子类中的方法和父类中的方法声明一样？\n通过子类对象调用方法：\nA先找子类中，看有没有这个方法有就用\nb再看父类中，有没有这个方法，有就用\nc如果没有报错\n方法重写的注意事项A:父类中私有方法不能被重写因为父类私有方法子类根本就无法继承\nB：子类重写父类的方法时，访问权限不能更低\nc：父类静态方法，子类也必须通过静态方法进行重写\nfinal:最终的意思。它可以修饰类，方法，变量特点：\nfinal可以修饰类，该类不能被继承\nfinal可以修饰方法，该方法不能被重写\nfinal可以修饰变量，该变量不能被重新赋值，因为这个变量其实是常量\nfinal修饰局部变量A.基本类型 值不能变B.引用类型地址不能变。\n\nfinal 修饰变量的初始化时机：\nA:被final修饰的变量只能赋值一次\nB:在构造方法完毕前。（非静态的常量）\n多态：同一（对象）事物，在不同时刻体现出来的不同状态多态的前提：\nA要有继承关系\nB要有方法重写\nC要有父类引用指向子类对象\n父 f  &#x3D; new 子（）；\n多态访问成员特点\nA:成员变量\n编译看左边，运行看右边\nB构造方法\n创建子类对象的时候访问父类的构造方法，对父类数据进行初始化\nC：成员方法\n编译看左边，运行看右边\nD：静态方法\n编译看左边，运行看做左边\n（静态和类相关，算不算重写，所有访问还是左边）\n多态的好处：\nA：提高了代码的维护性（继承保证）\nB：提高了代码的扩展性（多态保证）\n多态的弊端：\n不能使用子类的特有功能\n怎么用？\nA：创建子类对象调用方法即可。（可以，但是很多时候不合理，并且占内存）\nB:把父类的引用强制转换为子类的引用（向下转型）\n对象间的转型问题：\n向上转型：\nFu f &#x3D;new Zi();\n向下转型：\nZi z &#x3D;(Zi)f;&#x2F;&#x2F;要求该f必须是能够转换为Zi的\n抽象类的概述：动物不应该定义为具体的东西，而且动物中的吃，睡等也不应该是具体的。\n我们把一个不是具体的功能称为抽象的功能，而一个类中如果有抽象的功能，该类必须是抽象类\n抽象类的特点：\nA：抽象类和抽象方法必须用abstract关键字修饰\nB:抽象类中不一定有抽象方法，但又抽象方法的类一定是抽象类\nC:抽象类不能实例化    因为它不是具体的。抽象类又构造方法，但是不能实例化？构造方法的作用是什么呢？用于子类访问父类数据的初始化\nD：抽象的子类\n​\ta：抽象类的子类是一个抽象类\n​\tb:重写所有的抽象方法，这个时候子类是是一个具体的类\n抽象类的实例化其实是靠具体的子类实现的是多态的方式\nAnimal a &#x3D; new Cat（）；\n抽象类的成员特点：\n成员变量：既可以是变量，也可以是常量\n构造方法：有用于子类访问父类数据的初始化\n成员方法：既可以是抽象的，也可以是非抽象的。\n抽象类的成员方法特性：\nA：抽象方法强制要求子类做的事情\nB：非抽象方法子类继承的事情提高代码复用性\nabstract不能和哪些关键字共存\nprivate 冲突\nfinal 冲突\nstatic 无意义\n接口特点A：接口用关键字interface表示\ninterface 接口名{}\nB:类实现1接口用implements表示\nclass 类名 implements 接口名{}                                                                                                                                                                         \nC:接口不能实例化\n那么，接口如何实例化呢？\n按多态的方式来实例化\nD:接口的子类\na;可以是抽象类但意义不大\nb;可以是具体类，要重写接口中的所有抽象方法     \n接口成员特点\n成员变量：只能是常量，并且是静态的\n默认修饰符public static final   建议：自己手动给出\n构造方法：接口没有构造方法\n成员方法：只能是抽象方法\n默认修饰符public static \n形式参数\n基本类型\n引用类型：\n​\t\t\t\t类名（匿名对象）需要该类的对象实例\n​\t\t\t\t抽象类：需要的是该抽象的类子类对象\n​\t\t\t\t接口：需要该接口的实现类对象\n返回类型\n​\t\t\t\t类名 返回的是该类的对象实例\n​\t\t\t\t抽象类：返回的是该抽象的类子类对象\n​\t\t\t\t接口：返回的是接口的实现类对象\n链式编程:每次调用完毕方法后，返回的是一个对象。\n包：\n​\t\tA:文件夹\n​\t\tB:作用 ————\n​\t\t\t\t\ta:对类进行分类管理\n​\t\t\t\t\tb：吧相同类名放到不同的包中\n导包：\n​\t\t\t格式： import 包名;\n修饰符\n​\t\t\t权限修饰符\n​\t\t\t状态修饰符  static final \n​\t\t\t抽象修饰符  abstract\n类：\n默认，public，final，abstract\n成员变量：\nprivate，默认，protected，public，static，final\n构造方法：private，默认，protected，public\n成员方法：都可以\n内部类：把类定义在其他类的内部内部类特点：A：内部类可以直接访问外部类的成员，包括私有、\n​\t\t\t\t\t\tB：外部类要访问内部类的成员，必须创建对象\n内部类的位置\n​\t\t\t\t\t成员位置：定义在成员位置的类，称为成员内部类\n​\t\t\t\t\t局部位置：定义在局部位置的类，称为局部内部类\n格式：外部类名.内部类名    对象名 &#x3D; 外部类对象.内部类对象\n局部内部类访问局部变量必须用final 修饰   ？\n局部变量会随方法结束而消失，但对象可能还需要使用这个变量，堆内存不会因此而消失\n匿名内部类\n​\t\t\t就是内部类的简化写法\n前提：存在一个类或者接口\n 格式：new 类名或者接口名（）{\n​\t\t\t重写方法；\t\t\t\n}\n本质：是一个继承了该类或者实现了该接口的子类匿名对象\nobject类的方法：\npublic int hashCode();返回该对象的哈希码值。\n哈希值与地址有关但不是地址值\npublic final Class getClass(); 返回此Object 的运行时类Class类的方法;\nequals:只比较引用类型默认比地址值\nprotected void finalize();当垃圾回收器确定不存在该对象的更多引用是，由对象的垃圾回收器调用此方法，用于垃圾回收，但什么时候回收不确定\nprotected Object clone();创建并返回此对象的一个副本\nScanner\n字符串：多个字符组成的数据\n字符串如果是变量，先开空间再拼接\n字符串如果是常量，先去常量池中找，若有返回，没有创建\n例子\n\n\n\n\nStringBuffer（）\n&lt;1&gt;用字符串做拼接，比较耗时并且也耗内存，而且这种拼接操作又是比较常见的，为了解决这个问题java提供了一个字符缓冲区类。StringBuffer供我们使用\n线程安全的可变字符串\nStringBuffer和String 的区别？\n前者长度内容可变后者不可变\n如果使用前者做字符串拼接，不会浪费太多资源\n&lt;2&gt;StringBuffer的构造方法\npublic StringBuffer()  无参构造\npublic StringBuffer(int capacity)：指定容量的字符串缓冲区对象\npublic StringBuffer(String str)  :指定字符串的字符串缓冲区对象\nStringBuffer的方法：\npublic int capacity()  ：返回当前容量 \npublic int length()  :返回长度\nappend：把任意类型数据添加道字符串缓冲区里面，并返回字符串缓冲区本身\n\n\n常见对象Integer\n* 常见进制转换\n* public static String toBinaryString(int i)\n*                      toOctalString(int i)\n*                       toHexString(int i)\n* 十进制转其他进制\n* Public static String  toString(itn i,int radix)\n*\n*其他进制转到十进制\n* public static int parseInt(String s,int radix)\n\njdk1.5新特性\n自动装箱：把基本类型转换为包装类类型\n自动拆箱：把包装类型转换为基本类型\n\n注意：在使用中，Interger x &#x3D;null; 代码就会出现NullPointerException\nCharacter类\n对象中包装一个基本类型char的值\n此外，该类提供了几种方法，已确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然\n方法\npublic static boolean isUpperCase(char ch)：判断字符是否是大写\nisLowerCase(char ch) :判断给定的字符是否是小写字符\nisDigit（char ch）：判断给定的字符是否是数字字符\npublic staitc char toUpperCase(char ch):把给定的字符转换成大写字符\ntoLowerCase(char ch):把给定字符转换为小写字符\n正则表达式\n\n\n\nMath类概述及其成员方法\n\nSystem类\n\ngc ：垃圾回收器\nexit：终止当前正在运行的Java虚拟机.参数用作状态码；根据惯例，非零的状态码表示异常终止\ncurrentTimeMillis():返回以毫米为单位的当前时间\narraycopy:从指定数组中复制一个数组，复制从指定位置开始，到目标数组指定位置结束\nBigDecimal类\n\n","slug":"javase","date":"2022-07-12T09:00:43.880Z","categories_index":"","tags_index":"","author_index":"Aurora"}]